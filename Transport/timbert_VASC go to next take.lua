-- @description VASC Go to next take
-- @author Thomas Imbert
-- @version 1.0
-- @link GitHub repository https://github.com/ThomasImbert/REAPER-ReaScripts
-- @about Moves edit cursor and region selection to the next VASC Guide track segment without interrupting recording.
-- @changelog 
--   # Initial release

-- #local declarations#

-- Get computer specific ID of "SWS: Save Selected track(s) selected item(s), slot 1"
local save_item_slot_1_ID = reaper.NamedCommandLookup("_SWS_SAVESELITEMS1") 
-- Get computer specific ID of "SWS: Restore Selected track(s) selected item(s), slot 1"
local restore_item_slot_1_ID = reaper.NamedCommandLookup("_SWS_RESTSELITEMS1") 
-- Get computer specific ID of "_SWS_SAVESEL"
local sws_saveCurrentTrackSelection = reaper.NamedCommandLookup("_SWS_SAVESEL") 
-- Get computer specific ID of "_SWS_RESTORESEL"
local sws_restoreTrackSelection = reaper.NamedCommandLookup("_SWS_RESTORESEL")  
-- Get computer specific ID of "_SWS_TOGSAVESEL" SWS: Toggle between current and saved track selection
local sws_toggleCurrentAndSavedTrackSelection = reaper.NamedCommandLookup("_SWS_TOGSAVESEL") 
-- Get computer specific ID of "_XENAKIOS_SELITEMSUNDEDCURSELTX"
local sws_selectItems_editCursor_onSelectedTracks = reaper.NamedCommandLookup("_XENAKIOS_SELITEMSUNDEDCURSELTX") 
-- Get computer specific ID of "_SWS_SAVEALLSELITEMS1"
local sws_saveSelectedItems = reaper.NamedCommandLookup("_SWS_SAVEALLSELITEMS1") 
-- Get computer specific ID of "_SWS_RESTALLSELITEMS1"
local sws_restoreSelectedItems = reaper.NamedCommandLookup("_SWS_RESTALLSELITEMS1") 
-- Get computer specific ID of "_SWS_HSCROLL10"
local sws_hozScroll = reaper.NamedCommandLookup("_SWS_HSCROLL10")

function storeNotes()
  if reaper.CountSelectedMediaItems( 0 ) > 0 then -- Check that an item is selected
    local selItem = reaper.GetSelectedMediaItem( 0 , 0 )
    local itemNotes = ""
    local boolean, itemNotes = reaper.GetSetMediaItemInfo_String(selItem , "P_NOTES", itemNotes, false)
    reaper.DeleteExtState( "vascReaper", "vascNotes", false )
    reaper.SetProjExtState( 0, "vascReaper", "vascNotes", tostring(itemNotes)) 
  end 
end

function pasteNotes()     
  if reaper.CountSelectedMediaItems( 0 ) > 0 then -- Check that an item is selected
    local selItem = reaper.GetSelectedMediaItem( 0 , 0 )
    retval, itemNotes = reaper.GetProjExtState( 0, "vascReaper", "vascNotes")
    reaper.GetSetMediaItemInfo_String(selItem , "P_NOTES", itemNotes, true)
  end
end

function regionTimeSelect() -- from Thonex: Set time selection to region at edit cursor  
  Cur_Pos =  reaper.GetCursorPosition()                                                             
  markeridx, regionidx = reaper.GetLastMarkerAndCurRegion( 0, Cur_Pos)
  retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(  regionidx )
  reaper.GetSet_LoopTimeRange(true, false, pos, rgnend, false )
end

-- This script was generated by Lokasenna_Select tracks by name.lua
local settings = {
  matchmultiple = false,
  search = "GUIDE",
  selchildren = false,
  selparents = false,
  selsiblings = false,
  matchonlytop = false,
}


local info = debug.getinfo(1,'S');
script_path = info.source:match[[^@?(.*[\/])[^\/]-$]]
local script_filename = ({reaper.get_action_context()})[2]:match("([^/\\]+)$")

-------- Search Functions ----------

-- Returns true if the individual words of str_b all appear in str_a
local function fuzzy_match(str_a, str_b)

    if not (str_a and str_b) then return end
    str_a, str_b = string.lower(tostring(str_a)), string.lower(tostring(str_b))

    --Msg("\nfuzzy match, looking for:\n\t" .. str_b .. "\nin:\n\t" .. str_a .. "\n")

    for word in string.gmatch(str_b, "[^%s]+") do
     --Msg( tostring(word) .. ": " .. tostring( string.match(str_a, word) ) )
     if not string.match(str_a, word) then return end
    end
    return true
end

local function is_match(str, tr_name, tr_idx)
    if str:sub(1, 1) == "#" then
     -- Force an integer until/unless I come up with some sort of multiple track syntax
     str = tonumber(str:sub(2, -1))
     return str and (math.floor( tonumber(str) ) == tr_idx)

    elseif tostring(str) then
     return fuzzy_match(tr_name, tostring(str))
    end
end

local function merge_tables(...)

    local tables = {...}

    local ret = {}
    for i = #tables, 1, -1 do
     if tables[i] then
      for k, v in pairs(tables[i]) do
       if v then ret[k] = v end
      end
     end
    end

    return ret

end

local function get_tracks_to_sel(settings)
    --[[
     settings = {
      search = str,

      matchmultiple = bool,
      matchonlytop = bool,
      selchildren = bool,
      selparents = bool,

      mcp = bool,
      tcp = bool
     }
    ]]--
    local matches = {}

    -- Find all matches
    for i = 1, reaper.CountTracks(0) do

     local tr = reaper.GetTrack(0, i - 1)
     local _, name = reaper.GetTrackName(tr, "")
     local idx = math.floor( reaper.GetMediaTrackInfo_Value(tr, "IP_TRACKNUMBER") )
     local ischild = reaper.GetTrackDepth(tr) > 0

     if is_match(settings.search, name, idx) and not (ischild and settings.matchonlytop) then
      matches[idx] = true
      if not settings.matchmultiple then break end
     end
    end
    -- Hacky way to check if length of a hash table == 0
    for k in pairs(matches) do
     if not k then return {} end
    end

    return merge_tables(matches)
end

local function set_selection(tracks, settings)
    if not tracks then return end
    --if not tracks or #tracks == 0 then return end

    for i = 1, reaper.CountTracks(0) do

     local tr = reaper.GetTrack(0, i - 1)
     local keep = settings.add_selection and reaper.IsTrackSelected(tr)
     reaper.SetTrackSelected(tr, not not (tracks[i] or keep))
    end
    reaper.TrackList_AdjustWindows(false)
end

function selectGuide()
  local tracks = get_tracks_to_sel(settings)
  if tracks then
    set_selection( tracks, settings )
    return
  end
end
-- End of the Lokasenna_Select tracks by name.lua script


function goToNextTake()     

  -- Save current track selection
  reaper.Main_OnCommand(sws_saveCurrentTrackSelection, 0)
  selectGuide()
  -- _XENAKIOS_SELITEMSUNDEDCURSELTX
  reaper.Main_OnCommand(sws_selectItems_editCursor_onSelectedTracks, 0)
  -- Item: Select and move to next item
  reaper.Main_OnCommand(40417, 0)
  -- SWS: Toggle between current and saved track selection
  reaper.Main_OnCommand(sws_toggleCurrentAndSavedTrackSelection, 0)
  -- Set time selection to region at edit cursor.lua
  regionTimeSelect()

end

function goToNextTakeRec()     

  -- Save current track selection
  reaper.Main_OnCommand(sws_saveCurrentTrackSelection, 0)
  -- "SWS: Save Selected track(s) selected item(s), slot 1"
  reaper.Main_OnCommand(save_item_slot_1_ID, 0)
  -- Select Guide track exclusively
  selectGuide()
  -- _XENAKIOS_SELITEMSUNDEDCURSELTX
  reaper.Main_OnCommand(sws_selectItems_editCursor_onSelectedTracks, 0)
  -- timbert_Store selected item notes.lua 
  storeNotes()
  -- Item: Select and move to next item
  reaper.Main_OnCommand(40417, 0)
  -- "SWS: Save Selected track(s) selected item(s), slot 1"
  reaper.Main_OnCommand(save_item_slot_1_ID, 0)
  -- Item: Unselect (clear selection of) all items
  reaper.Main_OnCommand(40289, 0)
  -- SWS: Toggle between current and saved track selection
  reaper.Main_OnCommand(sws_toggleCurrentAndSavedTrackSelection, 0)
  -- "SWS: Restore Selected track(s) selected item(s), slot 1"
  reaper.Main_OnCommand(restore_item_slot_1_ID, 0)
  -- Paste to selected item notes
  pasteNotes()
  -- SWS: Toggle between current and saved track selection
  reaper.Main_OnCommand(sws_toggleCurrentAndSavedTrackSelection, 0)
  -- "SWS: Restore Selected track(s) selected item(s), slot 1"
  reaper.Main_OnCommand(restore_item_slot_1_ID, 0)
  -- SWS: Toggle between current and saved track selection
  reaper.Main_OnCommand(sws_toggleCurrentAndSavedTrackSelection, 0)
  -- Set time selection to region at edit cursor.lua
  regionTimeSelect()

end

reaper.PreventUIRefresh(1)

function main()
    -- Record state
    local record_command_state = reaper.GetToggleCommandState(1013) 
    
    -- If transport is stopped
    if reaper.GetToggleCommandState(1007) == 0 then
    goToNextTake()
    -- _SWS_HSCROLL10 Horizontal scroll to put edit cursor at 10%
    reaper.Main_OnCommand(sws_hozScroll, 0)
    return end

    -- If Record is off
    if record_command_state  == 0 then 
    -- Transport: Stop
    reaper.Main_OnCommand(40667, 0) 
    goToNextTake()
    -- _SWS_HSCROLL10 Horizontal scroll to put edit cursor at 10%
    reaper.Main_OnCommand(sws_hozScroll, 0)
    -- Transport: Play
    reaper.Main_OnCommand(1007, 0) 
    return end

   -- Transport: Stop
   reaper.Main_OnCommand(40667, 0) 
   goToNextTakeRec()
   -- _SWS_HSCROLL10 Horizontal scroll to put edit cursor at 10%
   reaper.Main_OnCommand(sws_hozScroll, 0)
   -- Transport: Record
   reaper.Main_OnCommand(1013, 0)  
end

reaper.Undo_BeginBlock() -- Begining of the undo block. Leave it at the top of your main function.

main()

reaper.UpdateArrange()

reaper.Undo_EndBlock("VASC Go to the next take", -1 ) -- End of the undo block. Leave it at the bottom of your main function.

reaper.PreventUIRefresh(-1)